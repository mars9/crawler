// Copyright 2016 Markus Sonderegger. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"os/exec"
	"path"
	"strings"
)

var (
	filename = path.Join("src", "github.com", "boltdb", "bolt", "errors.go")
	raw      = flag.Bool("raw", false, "write unformatted source to stdout")
	outfile  = flag.String("o", "", "output filename")

	fatalErrors = map[string]string{
		"ErrBucketNameRequired": "StorageError(err.Error())",
		"ErrBucketNotFound":     "StorageError(err.Error())",
		"ErrBucketExists":       "StorageError(err.Error())",
		"ErrTxNotWritable":      "StorageError(err.Error())",
		"ErrIncompatibleValue":  "StorageError(err.Error())",
		"ErrTxClosed":           "StorageError(err.Error())",
		"ErrDatabaseReadOnly":   "StorageError(err.Error())",
		"ErrInvalid":            "StorageError(err.Error())",
		"ErrVersionMismatch":    "StorageError(err.Error())",
		"ErrChecksum":           "StorageError(err.Error())",
	}

	protocolErrors = map[string]string{
		"ErrDatabaseNotOpen": "Error(err.Error())",
		"ErrDatabaseOpen":    "Error(err.Error())",
		"ErrKeyRequired":     "Error(err.Error())",
		"ErrKeyTooLarge":     "Error(err.Error())",
		"ErrValueTooLarge":   "Error(err.Error())",
		"ErrTimeout":         "Error(err.Error())",
	}
)

func genErrors(w io.Writer, root string) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, root, nil, 0)
	if err != nil {
		log.Fatalf("parsing boltdb: %v", err)
	}

	buf := &bytes.Buffer{}
	buf.WriteString(header)
	for name, obj := range f.Scope.Objects {
		if obj.Kind == ast.Var && strings.HasPrefix(name, "Err") {
			str, found := protocolErrors[name]
			if found {
				tmp := fmt.Sprintf("\t\tcase err == bolt.%s:\n", name)
				tmp += fmt.Sprintf("\t\t\treturn %s\n", str)
				buf.WriteString(tmp)
				continue
			}

			str, found = fatalErrors[name]
			if found {
				tmp := fmt.Sprintf("\t\tcase err == bolt.%s:\n", name)
				tmp += fmt.Sprintf("\t\t\treturn %s\n", str)
				buf.WriteString(tmp)
				continue
			}

			log.Fatal("found unhandled error: %s", name)
		}
	}
	buf.WriteString(footer)

	if *raw {
		if _, err = io.Copy(w, buf); err != nil {
			log.Fatalf("writing source: %v", err)
		}
	} else {
		if err = formatter(w, buf); err != nil {
			log.Fatalf("formatting source: %v", err)
		}
	}
}

func formatter(w io.Writer, buf *bytes.Buffer) (err error) {
	cmd := exec.Command("gofmt")
	in, err := cmd.StdinPipe()
	if err != nil {
		return err
	}
	out, err := cmd.StdoutPipe()
	if err != nil {
		return err
	}
	if err = cmd.Start(); err != nil {
		return err
	}
	if _, err = in.Write(buf.Bytes()); err != nil {
		return err
	}
	in.Close()

	if _, err = io.Copy(w, out); err != nil {
		return err
	}
	return cmd.Wait()
}

func main() {
	flag.Parse()
	var w io.Writer
	if *outfile != "" {
		f, err := os.Create(*outfile)
		if err != nil {
			log.Fatalf("%s", err)
		}
		defer f.Close()
		w = f
	} else {
		w = os.Stdout
	}
	fmt.Fprintf(w, "// generated by gen-error %s; DO NOT EDIT\n\n",
		strings.Join(os.Args[1:], " "))
	genErrors(w, path.Join(os.Getenv("GOPATH"), filename))
}

const header = `package db

import "github.com/boltdb/bolt"

type StorageError string

func (e StorageError) Error() string { return string(e) }

type Error string

func (e Error) Error() string { return string(e) }

func checkErr(err error) error {
	if err == nil {
		return nil
	}
	switch {
`

const footer = `}
	return err // return original error
}
`
